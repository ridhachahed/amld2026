---
import WorkshopPartLayout from "@/layouts/WorkshopPartLayout.astro";

const title = "Part 3 ‚Äî Build a Hotel Booking Agent with HeatWave GenAI";
const baseUrl = import.meta.env.BASE_URL;

const exerciseNotebook = `${baseUrl}assets/notebooks/amld-heatwave-genai-lab.ipynb`;
const solutionNotebook = `${baseUrl}assets/notebooks/amld-heatwave-genai-lab-solution.ipynb`;
---

<WorkshopPartLayout
  title={title}
  description={title}
  partLabel="Part 3 of 3"
  heading="Build a Hotel Booking Agent with HeatWave GenAI"
  lead="From CRUD tools to RAG over invoices ‚Äî all inside MySQL HeatWave."
  active="rag"
>
  <section class="section">
    <div class="section-label">Architecture</div>
    <h2>The loop ‚Äî think ‚Üí call a tool ‚Üí observe ‚Üí answer</h2>
    <p>
      This lab uses a <strong>ReAct agent</strong> powered by HeatWave‚Äôs in-database LLM.
      The mental model is simple: <strong>the LLM is the planner</strong>, and <strong>tools are the hands</strong>.
      Instead of hoping the model ‚Äúknows‚Äù your hotel inventory or invoice pricing,
      we give it small, reliable functions that can <em>read</em> and <em>write</em> the database (and retrieve documents).
    </p>

    <p>
      In practice, the agent runs in a loop:
      it reads your request, decides which tool to call, inspects the tool output, and repeats until it can answer.
      When this works well, it feels like chatting with a ‚Äúbooking assistant‚Äù ‚Äî but under the hood it‚Äôs just
      <strong>structured tool calls + SQL + retrieval</strong>.
    </p>

    <div class="diagram-card">
      <div class="caption">Fig 7 ‚Äî Hotel booking agent (SQL tools + RAG tool)</div>

      <div class="mini-diagram" role="img" aria-label="Agent architecture ‚Äî user to ReAct agent, which calls SQL tools or a RAG tool backed by HeatWave.">
        <div class="mini-diagram__row">
          <div class="mini-diagram__box">User</div>
        </div>

        <div class="mini-diagram__row">
          <div class="mini-diagram__arrow">‚Üì</div>
        </div>

        <div class="mini-diagram__row">
          <div class="mini-diagram__box mini-diagram__box--agent">
            LangChain ReAct Agent
            <span>MyLLM (HeatWave) + tool descriptions</span>
          </div>
        </div>

        <div class="mini-diagram__row mini-diagram__row--tools">
          <div class="mini-diagram__box mini-diagram__box--sql">
            SQL Tools (CRUD)
            <span>search / book / cancel / update</span>
          </div>
          <div class="mini-diagram__box mini-diagram__box--db">
            MySQL HeatWave
            <span>data + inference + ML_RAG</span>
          </div>
          <div class="mini-diagram__box mini-diagram__box--rag">
            RAG Tool
            <span>invoice PDFs ‚Üí citations</span>
          </div>
        </div>
      </div>
    </div>

    <div class="diagram-card">
      <div class="caption">Fig 8 ‚Äî The ReAct loop (what <code>verbose=True</code> shows you)</div>

      <div class="mini-diagram" role="img" aria-label="ReAct loop diagram ‚Äî question, tool selection, observation, final answer.">
        <div class="mini-diagram__row mini-diagram__row--react">
          <div class="mini-diagram__box mini-diagram__box--react">User question</div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--react">Thought</div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--react">Action (tool)</div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--react">Observation</div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--react">Final answer</div>
        </div>
      </div>
    </div>

    <div class="notebook-downloads" aria-label="Notebook downloads">
      <a class="notebook-box notebook-box--exercise" href={exerciseNotebook} download>
        <div class="notebook-box__eyebrow">Notebook</div>
        <div class="notebook-box__title">Agent exercises</div>
        <div class="notebook-box__desc">Follow along and implement the missing tool code.</div>
        <div class="notebook-box__cta">Download ‚Üí</div>
      </a>

      <a class="notebook-box notebook-box--solution" href={solutionNotebook} download>
        <div class="notebook-box__eyebrow">Notebook</div>
        <div class="notebook-box__title">Solution (download at the end)</div>
        <div class="notebook-box__desc">Completed notebook for reference after the lab.</div>
        <div class="notebook-box__cta">Download ‚Üí</div>
      </a>
    </div>
  </section>

  <section class="section">
    <div class="section-label">Step 1</div>
    <h2>Connect to MySQL (sanity check)</h2>
    <p>
      In MySQL Studio, you already have credentials in the environment. Connect using <code>MYSQL_USER</code> and run a tiny query.
      If you see <code>(1,)</code>, you‚Äôre ready.
    </p>

    <div class="callout">
      <p>
        <strong>Why this matters</strong> ‚Äî every tool call you build later is just ‚Äúrun a SQL statement and return a structured result‚Äù.
        If the connection is flaky, the agent will look unreliable even if your prompts are perfect.
      </p>
    </div>

    <div class="code-block">
      <pre><code>import os
import mysql.connector

mydb = mysql.connector.connect(database=os.environ["MYSQL_USER"])

cursor = mydb.cursor()
cursor.execute("SELECT 1")
print(cursor.fetchone())</code></pre>
    </div>
  </section>

  <section class="section">
    <div class="section-label">Step 2</div>
    <h2>Create an agent (and watch it fail)</h2>
    <p>
      Before building real tools, create a minimal <strong>ReAct agent</strong> backed by HeatWave‚Äôs in-database LLM.
      We add a placeholder tool, then ask it to book a hotel.
    </p>

    <p>
      This is a useful ‚Äúcalibration‚Äù moment:
      you‚Äôll see the agent try to be helpful, but it has no way to check availability or persist a booking.
      That gap is exactly what tools fill.
    </p>

    <div class="code-block">
      <pre><code>from mysql.ai.genai import MyLLM

from langchain_classic.agents.initialize import initialize_agent, AgentType
from langchain_core.tools import Tool

myllm = MyLLM(mydb).bind(model_id="meta.llama-3.3-70b-instruct")


dummy_tool = Tool(
    name="Placeholder",
    func=lambda x: "No real tools available yet.",
    description="A placeholder tool that does nothing useful.",
)


agent = initialize_agent(
    llm=myllm,
    tools=[dummy_tool],
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True,
    return_intermediate_steps=True,
    handle_parsing_errors=True,
    max_iterations=2,
    early_stopping_method="generate",
)

agent.invoke("Book the Hilton Basel for me!")</code></pre>
    </div>

    <div class="callout">
      <p>
        <strong>What does <code>AgentType.ZERO_SHOT_REACT_DESCRIPTION</code> mean?</strong>
        LangChain uses this setting to run a ReAct-style agent that chooses tools <em>zero-shot</em>.
        In other words: it reads the <strong>tool descriptions</strong>, decides which tool to call,
        observes the result, and repeats until it can answer.
      </p>
    </div>

    <figure class="asset-figure">
      <img
        src={`${baseUrl}assets/react.png`}
        alt="ReAct pattern: reasoning + action with tool observations"
        loading="lazy"
        class="asset-figure__img"
      />
      <figcaption class="asset-figure__caption">ReAct: interleave reasoning and tool calls.</figcaption>
    </figure>

    <div class="callout">
      <p><strong>Expected behavior</strong> ‚Äî it can‚Äôt actually book anything. Without tools, the agent has no way to read availability or update bookings.</p>
    </div>

    <div class="callout">
      <p>
        <strong>Tip</strong> ‚Äî keep <code>verbose=True</code> while developing. It lets you debug:
        did the model pick the wrong tool, or did the tool return the wrong data?
      </p>
    </div>
  </section>

  <section class="section">
    <div class="section-label">Step 3</div>
    <h2>Introspect the <code>hotels</code> table</h2>
    <p>
      Tools are just functions. To write good tools, we need to know the schema.
      In this lab, the agent operates on a <code>hotels</code> table with booking state and optional dates.
    </p>

    <p>
      Think of the schema as the agent‚Äôs ‚Äúworld state‚Äù.
      If you can answer a question by looking at a row in <code>hotels</code>, then a tool can answer it too.
      If you need information that isn‚Äôt in the table (like pricing), that‚Äôs where the RAG tool comes in later.
    </p>

    <div class="diagram-card">
      <div class="caption">Fig 8 ‚Äî Schema snapshot (what the SQL tools operate on)</div>

      <div class="schema-diagram" role="img" aria-label="Database schema diagram ‚Äî hotels table with key columns used by tools.">
        <div class="schema-diagram__table">
          <div class="schema-diagram__title">hotels</div>
          <div class="schema-diagram__row"><code>id</code> <span class="schema-diagram__meta">PK</span></div>
          <div class="schema-diagram__row"><code>name</code> <span class="schema-diagram__meta">text</span></div>
          <div class="schema-diagram__row"><code>location</code> <span class="schema-diagram__meta">text</span></div>
          <div class="schema-diagram__row"><code>booked</code> <span class="schema-diagram__meta">0/1</span></div>
          <div class="schema-diagram__row"><code>checkin_date</code> <span class="schema-diagram__meta">date</span></div>
          <div class="schema-diagram__row"><code>checkout_date</code> <span class="schema-diagram__meta">date</span></div>
        </div>

        <div class="schema-diagram__note">
          <strong>Note:</strong> pricing is <em>not</em> in this table.
          Pricing questions are answered later via the RAG tool over invoice PDFs.
        </div>
      </div>
    </div>

    <div class="code-block">
      <pre><code>import pandas as pd

pd.read_sql("SELECT * FROM hotels LIMIT 10", mydb)</code></pre>
    </div>

    <table class="data-table">
      <thead>
        <tr>
          <th>Column</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr><td><code>id</code></td><td>Primary key used by tools</td></tr>
        <tr><td><code>name</code></td><td>Hotel name (e.g. Hilton Basel)</td></tr>
        <tr><td><code>location</code></td><td>City</td></tr>
        <tr><td><code>booked</code></td><td><code>1</code> booked, <code>0</code> available</td></tr>
        <tr><td><code>checkin_date</code> / <code>checkout_date</code></td><td>Reservation dates</td></tr>
      </tbody>
    </table>
  </section>

  <section class="section">
    <div class="section-label">Step 4</div>
    <h2>Give the agent hands ‚Äî CRUD tools</h2>
    <p>
      Now we create five tools. Each tool has (1) a Python function that runs SQL, and (2) a <code>Tool</code> wrapper with a name and description.
      The description is part of your ‚ÄúAPI‚Äù ‚Äî the LLM uses it to decide which tool to call and how to format the input.
    </p>

    <div class="diagram-card">
      <div class="caption">Fig 9 ‚Äî How a tool bridges natural language to SQL</div>

      <div class="mini-diagram" role="img" aria-label="Tool bridge diagram ‚Äî prompt to tool description to function to SQL to JSON output.">
        <div class="mini-diagram__row mini-diagram__row--tools">
          <div class="mini-diagram__box mini-diagram__box--tool">
            Tool description
            <span>name + input contract + when to use</span>
          </div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--tool">
            Python function
            <span>parse input, run SQL, return JSON</span>
          </div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--db">
            MySQL HeatWave
            <span>SELECT / UPDATE / commit</span>
          </div>
        </div>
      </div>
    </div>

    <div class="callout">
      <p>
        <strong>Tool design rule of thumb</strong> ‚Äî keep tools narrow and predictable.
        Prefer returning JSON (not prose), and let the agent write the narrative.
      </p>
    </div>

    <div class="info-grid">
      <div class="info-card">
        <div class="icon">üîé</div>
        <h3>Search</h3>
        <p>Find candidate hotels by location or name.</p>
      </div>
      <div class="info-card">
        <div class="icon">üßæ</div>
        <h3>Book / Cancel</h3>
        <p>Write to the database (set <code>booked</code> to 1 or 0).</p>
      </div>
      <div class="info-card">
        <div class="icon">üìÖ</div>
        <h3>Update dates</h3>
        <p>Parse <code>hotel_id, checkin, checkout</code> and update the row.</p>
      </div>
    </div>

    <h3>Tool 1 ‚Äî Search by location</h3>
    <p>
      The agent‚Äôs first job is to <strong>ground the conversation in real rows</strong>.
      When a user says ‚ÄúFind me hotels in Basel‚Äù, the model shouldn‚Äôt guess ‚Äî it should call a tool that
      returns the matching candidates.
      That result becomes the context for the next step (choosing an <code>id</code> to book, updating dates, etc.).
    </p>
    <div class="code-block">
      <pre><code>def search_hotels_by_location(location):
    location = location.split("\n")[0].strip()
    df = pd.read_sql("SELECT * FROM hotels WHERE location = %s", mydb, params=(location,))
    return df.to_json(orient="records")

search_hotels_by_location_tool = Tool(
    name="Search hotels by location",
    func=search_hotels_by_location,
    description="Search hotels by location.",
)</code></pre>
    </div>

    <div class="callout">
      <p><strong>Why sanitize the input?</strong> Tool inputs sometimes include extra text (newlines, commentary). Cleaning the string makes your SQL tools more robust.</p>
    </div>

    <div class="callout">
      <p>
        <strong>What the agent ‚Äúsees‚Äù</strong> ‚Äî it doesn‚Äôt see your source code; it sees the tool <em>name</em> and <em>description</em>.
        That‚Äôs why descriptions should include: what the tool does, required inputs, and what it returns.
      </p>
    </div>

    <h3>Try it</h3>
    <div class="code-block">
      <pre><code>tools = [search_hotels_by_location_tool]
agent = initialize_agent(
    llm=myllm,
    tools=tools,
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True,
    return_intermediate_steps=True,
    handle_parsing_errors=True,
    max_iterations=4,
    early_stopping_method="generate",
)

agent.invoke("Find me hotels in Basel?")</code></pre>
    </div>

    <h3>Tool 2 ‚Äî Search by name (fuzzy)</h3>
    <p>
      Users rarely type the exact hotel name stored in the database.
      This tool handles ‚Äúclose enough‚Äù queries and helps the agent map a request to a specific record.
    </p>
    <div class="code-block">
      <pre><code>def search_hotels_by_name(hotel_name):
    # TODO: Implement in the notebook.
    pass</code></pre>
    </div>

    <h3>Tool 3 ‚Äî Book a hotel (write)</h3>
    <p>
      Booking is the first write action.
      It should update a single hotel row and fail safely if the booking can‚Äôt be applied.
    </p>
    <div class="code-block">
      <pre><code>def book_hotel(hotel_id):
    # TODO: Implement in the notebook.
    pass</code></pre>
    </div>

    <h3>Tool 4 ‚Äî Cancel a booking</h3>
    <p>
      Cancel is the ‚Äúundo‚Äù operation.
      It should revert a booking in the database using a single, explicit update.
    </p>
    <div class="code-block">
      <pre><code>def cancel_hotel(hotel_id):
    # TODO: Implement in the notebook.
    pass</code></pre>
    </div>

    <h3>Tool 5 ‚Äî Update check-in / check-out</h3>
    <p>
      This tool updates dates after a hotel is selected.
      It‚Äôs a separate tool because date parsing and validation is a distinct concern from booking.
    </p>
    <p>
      LangChain tools accept a single string input, so we use a comma-separated contract.
      The tool description tells the model the exact format.
    </p>

    <div class="callout">
      <p>
        <strong>Why a strict input format?</strong> ‚Äî the easiest way to make agents reliable is to make tool inputs unambiguous.
        If you later switch to structured tool calling (JSON schema), the same principle applies.
      </p>
    </div>
    <div class="code-block">
      <pre><code>update_hotel_tool = Tool(
    name="Update hotel",
    func=update_hotel,
    description="Update hotel dates. Input: 'hotel_id, checkin_date, checkout_date' (e.g., '7, 2026-04-10, 2026-04-19')",
)</code></pre>
    </div>

    <div class="callout">
      <p><strong>Try a multi-action prompt</strong> ‚Äî ‚ÄúCancel Hilton Basel and book the Hyatt Regency instead.‚Äù A ReAct agent can chain multiple tool calls in one request.</p>
    </div>
  </section>

  <section class="section">
    <div class="section-label">Step 5</div>
    <h2>Add RAG ‚Äî answer pricing questions from invoices</h2>
    <p>
      The <code>hotels</code> table has no pricing. But invoices exist as PDFs in object storage.
      Load the PDF into HeatWave‚Äôs vector store (via the Chats UI), then create a tool that queries those documents.
    </p>

    <p>
      This is the ‚Äústory twist‚Äù of the lab:
      your agent can <em>transact</em> in SQL, but it can‚Äôt guess a price that isn‚Äôt stored in the table.
      With RAG, you give it a second sense: it can retrieve the relevant part of an invoice and answer with evidence.
    </p>

    <h3>Load the invoices into HeatWave vector store</h3>
    <ol>
      <li>Open the pre-authenticated request URL from the notebook.</li>
      <li>In MySQL Studio ‚Üí <strong>Chats</strong>, load the PDF into <strong>HeatWave vector store</strong>.</li>
      <li>Ask a pricing question to confirm retrieval works.</li>
    </ol>

    <h3>RAG tool design ‚Äî retrieve citations, let the agent answer</h3>
    <p>
      Call <code>sys.ML_RAG</code> with <code>skip_generate=true</code>. That returns relevant segments (citations) without a final narrative.
      Then the agent reads those segments and produces the final answer.
    </p>

    <div class="diagram-card">
      <div class="caption">Fig 10 ‚Äî RAG in one picture (retrieve ‚Üí then generate)</div>

      <div class="mini-diagram" role="img" aria-label="RAG diagram ‚Äî question to ML_RAG retrieval, citations, then LLM writes final answer.">
        <div class="mini-diagram__row mini-diagram__row--tools">
          <div class="mini-diagram__box mini-diagram__box--rag">
            Question
            <span>‚ÄúWhat‚Äôs the Hilton nightly rate?‚Äù</span>
          </div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--db">
            <code>sys.ML_RAG</code>
            <span>retrieve relevant invoice chunks</span>
          </div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--rag">
            Citations
            <span>snippets + file/page metadata</span>
          </div>
          <div class="mini-diagram__arrow">‚Üí</div>
          <div class="mini-diagram__box mini-diagram__box--agent">
            Agent answer
            <span>final narrative + references</span>
          </div>
        </div>
      </div>
    </div>

    <div class="callout">
      <p>
        <strong>Why <code>skip_generate=true</code>?</strong> ‚Äî it separates concerns.
        The database retrieves, the agent explains. This makes debugging and citation handling much easier.
      </p>
    </div>

    <div class="code-block">
      <pre><code>-- Retrieve relevant citations (no final generation)
CALL sys.ML_RAG(
  "input string",
  @response,
  JSON_OBJECT('skip_generate', true)
);
SELECT @response;</code></pre>
    </div>

    <div class="code-block">
      <pre><code>def rag(question):
    # 1) Call sys.ML_RAG(skip_generate=true)
    # 2) Parse JSON response
    # 3) Return a list of relevant invoice snippets
    # (Implemented in the notebook as an exercise)
    pass

rag_tool = Tool(
    name="Knowledge Base",
    func=rag,
    description="Useful for looking up hotel invoices.",
)</code></pre>
    </div>

    <h3>Test prompts</h3>
    <div class="code-block">
      <pre><code>agent.invoke("What is a price of accommodation at Hilton?")
agent.invoke("How much does a hotel room cost on average in the city of Bern?")</code></pre>
    </div>
  </section>

  <section class="section">
    <div class="section-label">Outcome</div>
    <h2>You now have an end-to-end agent</h2>
    <ul>
      <li><strong>CRUD via tools</strong> ‚Äî search, book, cancel, update dates</li>
      <li><strong>RAG via tools</strong> ‚Äî answer pricing questions from invoice PDFs</li>
      <li><strong>All inference in HeatWave</strong> ‚Äî no external LLM API calls</li>
    </ul>

    <div class="callout">
      <p><strong>Key takeaway</strong> ‚Äî tool descriptions are part of your ‚ÄúAPI‚Äù. Clear contracts (inputs/outputs) are what make agents reliable.</p>
    </div>

    <div class="callout">
      <p>
        <strong>A good finishing prompt</strong> ‚Äî ‚ÄúBook me an available hotel in Basel for next weekend,
        then tell me what similar stays cost based on the invoices.‚Äù
        You‚Äôll see the agent combine SQL tools (state) and RAG (knowledge) in a single conversation.
      </p>
    </div>
  </section>

  <style>
    .notebook-downloads {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 14px;
      margin-top: 14px;
    }

    @media (max-width: 720px) {
      .notebook-downloads {
        grid-template-columns: 1fr;
      }
    }

    .notebook-box {
      display: block;
      padding: 14px 14px 12px;
      border-radius: 14px;
      border: 1px solid color-mix(in oklab, var(--border) 70%, transparent);
      background: linear-gradient(
        135deg,
        color-mix(in oklab, var(--card) 88%, transparent),
        color-mix(in oklab, var(--accent) 18%, transparent)
      );
      box-shadow: var(--shadow-sm);
      text-decoration: none;
      transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
    }

    .notebook-box:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
      border-color: color-mix(in oklab, var(--accent) 35%, var(--border));
    }

    .notebook-box__eyebrow {
      font-family: var(--workshop-font-mono);
      font-size: 11px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted-foreground);
      margin-bottom: 6px;
    }

    .notebook-box__title {
      font-weight: 750;
      font-size: 16px;
      color: var(--foreground);
      margin-bottom: 6px;
    }

    .notebook-box__desc {
      color: var(--muted-foreground);
      font-size: 13px;
      line-height: 1.35;
      margin-bottom: 10px;
    }

    .notebook-box__cta {
      font-family: var(--workshop-font-mono);
      font-size: 12px;
      font-weight: 650;
      color: var(--foreground);
    }

    .notebook-box--exercise {
      background: linear-gradient(
        135deg,
        color-mix(in oklab, var(--card) 90%, transparent),
        color-mix(in oklab, var(--info) 16%, transparent)
      );
    }

    .notebook-box--exercise:hover {
      border-color: color-mix(in oklab, var(--info) 35%, var(--border));
    }

    .notebook-box--solution {
      background: linear-gradient(
        135deg,
        color-mix(in oklab, var(--card) 90%, transparent),
        color-mix(in oklab, var(--success) 16%, transparent)
      );
    }

    .notebook-box--solution:hover {
      border-color: color-mix(in oklab, var(--success) 35%, var(--border));
    }

    .mini-diagram {
      display: grid;
      gap: 12px;
      padding: 4px 0;
    }

    .mini-diagram__row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
    }

    .mini-diagram__row--tools {
      gap: 14px;
      flex-wrap: wrap;
    }

    .mini-diagram__row--react {
      flex-wrap: wrap;
      gap: 10px;
    }

    .mini-diagram__arrow {
      font-family: var(--workshop-font-mono);
      color: var(--muted-foreground);
    }

    .mini-diagram__box {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 14px;
      font-weight: 700;
      color: var(--foreground);
      text-align: center;
      min-width: min(260px, 100%);
      box-shadow: var(--shadow-sm);
    }

    .mini-diagram__box span {
      display: block;
      margin-top: 4px;
      font-weight: 500;
      font-size: 12px;
      color: var(--muted-foreground);
    }

    .mini-diagram__box--agent {
      background: color-mix(in oklab, var(--info) 10%, var(--card) 90%);
    }

    .mini-diagram__box--sql {
      background: color-mix(in oklab, var(--info) 8%, var(--card) 92%);
    }

    .mini-diagram__box--db {
      background: color-mix(in oklab, var(--accent) 10%, var(--card) 90%);
    }

    .mini-diagram__box--rag {
      background: color-mix(in oklab, var(--success) 10%, var(--card) 90%);
    }

    .mini-diagram__box--tool {
      background: color-mix(in oklab, var(--warning) 10%, var(--card) 90%);
    }

    .mini-diagram__box--react {
      background: color-mix(in oklab, var(--info) 8%, var(--card) 92%);
      min-width: 160px;
      padding: 10px 12px;
    }

    .schema-diagram {
      display: grid;
      grid-template-columns: minmax(240px, 380px) 1fr;
      gap: 14px;
      align-items: start;
      margin-top: 6px;
    }

    @media (max-width: 820px) {
      .schema-diagram {
        grid-template-columns: 1fr;
      }
    }

    .schema-diagram__table {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .schema-diagram__title {
      padding: 12px 14px;
      font-weight: 800;
      background: color-mix(in oklab, var(--accent) 10%, var(--card) 90%);
      border-bottom: 1px solid var(--border);
    }

    .schema-diagram__row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 14px;
      border-bottom: 1px solid color-mix(in oklab, var(--border) 70%, transparent);
      font-family: var(--workshop-font-mono);
      font-size: 13px;
    }

    .schema-diagram__row:last-child {
      border-bottom: 0;
    }

    .schema-diagram__meta {
      font-family: var(--workshop-font-mono);
      font-size: 12px;
      color: var(--muted-foreground);
    }

    .schema-diagram__note {
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid color-mix(in oklab, var(--border) 70%, transparent);
      background: color-mix(in oklab, var(--info) 6%, var(--card) 94%);
      color: var(--muted-foreground);
      box-shadow: var(--shadow-sm);
      font-size: 13px;
      line-height: 1.35;
    }

    .asset-figure {
      margin: 14px 0 0;
    }

    .asset-figure__img {
      width: 100%;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--card);
      box-shadow: var(--shadow-sm);
    }

    .asset-figure__caption {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted-foreground);
      text-align: center;
    }
  </style>
</WorkshopPartLayout>
